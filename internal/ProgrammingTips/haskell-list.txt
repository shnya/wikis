== Haskell List操作関数 ==
<<TableOfContents(3)>>
=== 一般List操作 ===
==== map :: (a -> b) -> [a] -> [b] ====
各要素に関数を適用
{{{
 map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
 map f [x1, x2, ...] == [f x1, f x2, ...]
}}}
==== (++) :: [a] -> [a] -> [a] ====
２つのリストを連結
{{{
 [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
 [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
}}}
==== filter :: (a -> Bool) -> [a] -> [a] ====
条件に一致する要素以外を削除
{{{
 filter p xs = [ x | x <- xs, p x]
}}}
==== head :: [a] -> a ====
リストの先頭を取り出す
==== last :: [a] -> a ====
リストの最後尾を取り出す
==== tail :: [a] -> [a] ====
リストの先頭を取り除いたリストを返す
==== init :: [a] -> [a] ====
最後尾を取り除いたリストを返す
==== length :: [a] -> Int ====
リストの長さを返す
==== (!!) :: [a] -> Int -> a ====
リストへのインデックスアクセス
==== reverse :: [a] -> [a] ====
リストを逆順にして返す

=== 畳み込み関数 ===
==== foldl :: (a -> b -> a) -> a -> [b] -> a ====
左方向に畳み込み演算を行う
{{{
 foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
}}}
==== foldl1 :: (a -> a -> a) -> [a] -> a ====
初期値を取らないfoldl
==== foldr :: (a -> b -> a) -> a -> [b] -> a ====
右方向に畳み込み演算を行う
==== foldr1 :: (a -> a -> a) -> [a] -> a ====
初期値を取らないfoldr

=== 特殊畳み込み関数 ===
==== and :: [Bool] -> Bool ====
リストの要素全てがTrueの場合にTrue, それ以外はFalse
==== or :: [Bool] -> Bool ====
リストの要素がひとつでもTrueの場合はTrue, それ以外はFalse
==== any :: (a -> Bool) -> [a] -> Bool ====
どれか一つでも述語関数を満たすものがあればTrue, それ以外はFalse
==== all :: (a -> Bool) -> [a] -> Bool ====
全ての要素が述語関数を満たす場合はTrue, それ以外はFalse
==== sum :: Num a => [a] -> a ====
リスト内の数値の合計を返す
==== product :: Num a => [a] -> a ====
リスト内の数値の積を返す
==== concat :: [[a]] -> [a] ====
複数のリストを一つのリストに連結する。空リストは無視される。
==== concatMap :: (a -> [b]) -> [a] -> [b] ====
各要素に関数を適用した結果をconcatする
==== maximum :: Ord a => [a] -> a ====
最大となる要素を返す
==== minimum :: Ord a => [a] -> a ====
最小となる要素を返す

=== リスト構築 ===
==== scanl :: (a -> b -> a) -> a -> [b] -> [a] ====
各要素に関数を適用してリストを構築する
{{{
 scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
}}}
==== scanl1 :: (a -> a -> a) -> [a] -> [a] ====
初期値のいらないscanl
==== scanr :: (a -> b -> b) -> b -> [a] -> [b] ====
scanlの右結合バージョン
{{{
 head (scanr f z xs) == foldr f z xs.
}}}
==== scanr1 :: (a -> a -> a) -> [a] -> [a] ====
初期値のいらないscanr

=== 無限リスト ===
==== iterate :: (a -> a) -> a -> [a] ====
関数を初期値に適用した結果を繰り返す
==== repeat :: a -> [a] ====
値を無限に繰り返す
==== replicate :: Int -> a -> [a] ====
n回値を繰り返したリストを返す
==== cycle :: [a] -> [a] ====
リストを循環して無限に返す

===  部分リスト ===
==== take :: Int -> [a] -> [a] ====
リストを先頭からn個取得する
==== drop :: Int -> [a] -> [a] ====
リストを先頭からn個削除した結果を返す
==== splitAt :: Int -> [a] -> ([a], [a]) ====
n以下のリストと、nより大きいリストをタプルで返す
==== takeWhile :: (a -> Bool) -> [a] -> [a] ====
先頭から、条件に一致する要素のリストを取得する
==== dropWhile :: (a -> Bool) -> [a] -> [a] ====
先頭から、条件に一致する要素を削除する
==== span :: (a -> Bool) -> [a] -> ([a], [a]) ====
条件によって、要素を２つに分割する。条件にマッチする要素は後者に。
{{{
 span (< 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
 span (< 9) [1,2,3] == ([1,2,3],[])
 span (< 0) [1,2,3] == ([],[1,2,3])
}}}
==== break :: (a -> Bool) -> [a] -> ([a], [a]) ====
条件によって、要素を２つに分割する。条件にマッチする要素は前者に。


=== リスト探索 ===
==== elem :: Eq a => a -> [a] -> Bool ====
リスト内に要素があるかどうか
==== notElem :: Eq a => a -> [a] -> Bool ====
リスト内に要素がないかどうか
==== lookup :: Eq a => a -> [(a, b)] -> Maybe b ====
連想リスト(タプルのリスト)から値を探索

=== ZIP関数 ===
==== zip :: [a] -> [b] -> [(a, b)] ====
２つのリストを結合して、１つのタプルリストにする
==== zip3 :: [a] -> [b] -> [c] -> [(a, b, c)] ====
3つのリストを結合して、１つのタプルリストにする
==== zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] ====
2つのリストの各要素に２引数関数を適用する
==== zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d] ====
3つのリストの各要素に3引数関数を適用する
==== unzip :: [(a, b)] -> ([a], [b]) ====
タプルリストを２つのリストに分解する
==== unzip3 :: [(a, b, c)] -> ([a], [b], [c]) ====
タプルリストを3つのリストに分解する


=== 文字列操作関数 ===
==== lines :: String -> [String] ====
文字列を改行で分割して各行のリストに変換
==== words :: String -> [String] ====
文字列をスペースで分割して単語のリストに変換
==== unlines :: [String] -> String ====
文字列のリストを改行を付与して一つの文字列に変換
==== unwords :: [String] -> String ====
文字列のリストを空白を付与して一つの文字列に変換

